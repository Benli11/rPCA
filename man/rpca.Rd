% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rpca.R
\name{rpca}
\alias{rpca}
\title{Randomized principal component analysis (rpca).}
\usage{
rpca(A, k = NULL, center = TRUE, scale = TRUE, retx = TRUE, p = 10,
  q = 2, rand = TRUE)
}
\arguments{
\item{A}{Array_like. \cr
A numeric input matrix (or data frame), with dimensions \eqn{(m, n)}. \cr
If the data contain \eqn{NA}s na.omit is applied.}

\item{k}{Int, optional. \cr
Determines the number of principle components to compute. It is required that \eqn{k} is smaller or equal to
\eqn{n}, but it is recommended that \eqn{k << min(m,n)}.}

\item{center}{Bool (\eqn{TRUE}, \eqn{FALSE}), optional. \cr
A logical value (\eqn{TRUE} by default) indicating whether the variables should be
shifted to be zero centered. Alternatively, a vector of length equal the number of
columns of \eqn{A} can be supplied. The value is passed to scale.}

\item{scale}{Bool (\eqn{TRUE}, \eqn{FALSE}), optional. \cr
A logical value (\eqn{TRUE} by default) indicating whether the variables should
be scaled to have unit variance. Alternatively, a vector of length equal the number of
columns of \eqn{A} can be supplied. The value is passed to scale.}

\item{retx}{Bool (\eqn{TRUE}, \eqn{FALSE}), optional \cr
A logical value (\eqn{TRUE} by default) indicating whether the rotated variables / scores
should be returned.}

\item{p}{Int, optional. \cr
Oversampling parameter for \eqn{rsvd}  (default \eqn{p=10}), see \code{\link{rsvd}}.}

\item{q}{Int, optional. \cr
Number of power iterations  for \eqn{rsvd} (default \eqn{q=1}), see \code{\link{rsvd}}.}

\item{rand}{Bool (\eqn{TRUE}, \eqn{FALSE}). \cr
If (\eqn{TRUE}), a probabilistic strategy is used, otherwise a deterministic algorithm is used.}

\item{.................}{.}
}
\value{
\code{rpca} returns a list with class \eqn{rpca} containing the following components:
   \item{rotation}{  Array_like. \cr
                     Matrix containing the rotation (eigenvectors); array with dimensions \eqn{(n, k)}.
   }

   \item{eigvals}{  Array_like. \cr
                    The eigenvalues; 1-d array of length \eqn{k}.
   }
   \item{sdev}{     Array_like \cr
                    The standard deviations of the principal components.
   }
   \item{x}{        Array_like \cr
                    If \eqn{retx} is true a matrix containing the scores / rotated data
                    (centred and scaled if requested) is returned.
   }
   \item{center, scale}{  Array_like .\cr
                    The centering and scaling used, or \eqn{FALSE}.
   }
   \item{.................}{.}
}
\description{
Principal components analysis using the randomized singular value decomposition.
}
\details{
Principal component analysis is a linear dimensionality reduction technique,
aiming to keep only the most significant principal components to allow
a better interpretation of the data and to project the data to a lower dimensional space.

Traditionally, the computation is done by a (deterministic) singular value decomposition.
Randomized PCA is computed using a fast randomized algorithm (\code{\link{rsvd}})
to compute the approximate low-rank SVD decomposition.
The computational gain is high if the desired number of principal components
is small, i.e. \eqn{k << min(m,n)}.

\code{\link{rsvd}} expects a numeric (real/complex) input matrix with dimensions \eqn{(m, n)}.
Given a target rank \eqn{k}, \code{rsvd} factors the input matrix \eqn{A} as
\eqn{A = W * diag(s) * W'}. The columns of the real or complex unitary matrix \eqn{W}
contain the eigenvectors (i.e. principal components). The vector \eqn{s} contains the corresponding
eigenvalues. Following \code{\link{prcomp}} we denote this matrix \eqn{W} as
rotation matrix (commonly also called loadings).

The print and summary method can be used to present the results in a nice format.
A scree plot can be produced with
\code{\link{ggscreeplot}}. The individuals factor map can be produced with \code{\link{ggindplot}},
and a correlation plot with \code{\link{ggcorplot}}.

The predict function can be used to compute the scores of new observations. The data
will automatically be centred (and scaled if requested). This is not fully supported for
complex input matrices.
}
\note{
The principal components are not unique and only defined up to sign
(a constant of modulus one in the complex case) and so may differ between different
 PCA implementations.

Similar to \code{\link{prcomp}} the variances are computed with the usual divisor N - 1.

Note, that \eqn{scale = TRUE} cannot be used, if some columns have only constant entries.
}
\examples{

library(rsvd)
#
# Load Edgar Anderson's Iris Data
#
data(iris)

#
# log transform
#
log.iris <- log( iris[ , 1:4] )
iris.species <- iris[ , 5]

#
# Perform rPCA and compute only the first two PCs
#
iris.rpca <- rpca(log.iris, k=2)
summary(iris.rpca) # Summary
print(iris.rpca) # Prints the rotations

#
# Use rPCA to compute all PCs, similar to \\code{\\link{prcomp}}
#
iris.rpca <- rpca(log.iris)
summary(iris.rpca) # Summary
print(iris.rpca) # Prints the rotations
plot(iris.rpca) # Produce screeplot, variable and individuls factor maps.


# You can compare the results with prcomp
# iris.pca <- prcomp(log.iris, center = TRUE, scale. = TRUE)
# summary(iris.pca) # Summary
# print(iris.pca) # Prints the rotations
}
\seealso{
\code{\link{ggscreeplot}}, \code{\link{ggindplot}},
         \code{\link{ggcorplot}}, \code{\link{plot.rpca}},
         \code{\link{predict}},   \code{\link{rsvd}}
}
\author{
N. Benjamin Erichson, \email{erichson@uw.edu}
}
